package sbtrestli

import java.io.File

import com.linkedin.pegasus.generator.PegasusDataTemplateGenerator
import sbt.Keys._
import sbt._
import sbtrestli.util.RestliCompilationException
import xsbti.Severity

import scala.collection.JavaConverters._

object DataTemplatePlugin extends AutoPlugin {
  object autoImport {
    val dataTemplateGenerate = taskKey[Seq[File]]("Compiles DataTemplate data-schemas into java source files.")
    val dataTemplatePackage = taskKey[File]("Packages DataTemplate data-templates into *-data-template.jar")

    val dataTemplateSettings: Seq[Def.Setting[_]] = Seq(
      includeFilter in dataTemplateGenerate := "*.pdsc",
      excludeFilter in dataTemplateGenerate := HiddenFileFilter,

      sourceDirectory in dataTemplateGenerate := sourceDirectory.value / "pegasus",
      sourceDirectories in dataTemplateGenerate := Seq((sourceDirectory in dataTemplateGenerate).value),

      sources in dataTemplateGenerate := Defaults.collectFiles(
        sourceDirectories in dataTemplateGenerate,
        includeFilter in dataTemplateGenerate,
        excludeFilter in dataTemplateGenerate).value,

      target in dataTemplateGenerate :=
        baseDirectory.value / "src" / (Defaults.nameForSrc(configuration.value.name) + "GeneratedDataTemplate") / "java",

      cleanFiles in Defaults.ConfigGlobal += (target in dataTemplateGenerate).value,

      dataTemplateGenerate := generate.value,

      sourceGenerators += dataTemplateGenerate.taskValue,
      managedSourceDirectories += (target in dataTemplateGenerate).value,
      exportedProducts ++= (sourceDirectories in dataTemplateGenerate).value,

      artifactClassifier in dataTemplatePackage := Some("data-template"),
      publishArtifact in dataTemplatePackage := true,

      packagedArtifacts in Defaults.ConfigGlobal ++= Classpaths.packaged(Seq(dataTemplatePackage)).value,
      artifacts in Defaults.ConfigGlobal ++= Classpaths.artifactDefs(Seq(dataTemplatePackage)).value
    ) ++ inTask(dataTemplateGenerate)(PluginCompat.watchSourcesSetting) ++
      Defaults.packageTaskSettings(dataTemplatePackage, Def.task {
        val sourceDir = (sourceDirectory in dataTemplateGenerate).value
        val originalSources = (sources in dataTemplateGenerate).value
        val rebasedSources = originalSources pair Path.rebase(sourceDir, "pegasus/")

        val targetDir = (target in dataTemplateGenerate).value
        val originalTargets = managedSources.value
        val rebasedTargets = originalTargets pair Path.relativeTo(targetDir)

        rebasedSources ++ rebasedTargets
      })
  }

  import autoImport._

  override def projectSettings: Seq[Def.Setting[_]] =
    inConfig(Compile)(dataTemplateSettings) ++ inConfig(Test)(dataTemplateSettings) ++ Seq(
      // For @Nonnull annotation in generated sources
      libraryDependencies += "com.google.code.findbugs" % "jsr305" % "3.0.+",
      libraryDependencies += "com.linkedin.dataTemplate" % "data" % BuildInfo.pegasusVersion

//      // Don't scala-version name-mangle this project, since it is intended equally for Java use
//      // and does not contain Scala-generated bytecode.
//      crossPaths := false,
//      autoScalaLibrary := false,
//      managedScalaInstance := false,
//
//      publishArtifact in packageBin := false,
//      publishArtifact in packageDoc := false,
//      publishArtifact in packageSrc := false,
    )

  private val JsonParseExceptionRegExp = """(?s).*\[Source: (.*?); line: (\d*), column: (\d*)\].*?""".r

  private lazy val generate = Def.task {
    val resolverFiles = (sourceDirectories in dataTemplateGenerate).value ++
      managedClasspath.value.files ++
      internalDependencyClasspath.value.files // adds in .pdscs from projects that this project .dependsOn
    val resolverPath = resolverFiles.map(_.getAbsolutePath).mkString(File.pathSeparator)

    val generatorResult = try {
      PegasusDataTemplateGenerator.run(
        resolverPath,
        null,
        baseDirectory.value.getAbsolutePath,
        false, // Class files included in "data-template" dependencies, no need to generate (I think)
        (target in dataTemplateGenerate).value.getAbsolutePath,
        (sources in dataTemplateGenerate).value.map(_.getAbsolutePath).toArray
      )
    } catch {
      case e: java.io.IOException => {
        e.getMessage match {
          case JsonParseExceptionRegExp(source, line, column) =>
            throw new RestliCompilationException(
              Some(file(source)),
              "JSON parse error in " + source + ": line: "  +  line.toInt + ", column:  " + column.toInt,
              Option(line.toInt), Option(column.toInt),
              Severity.Error)
          case _ =>
            throw new MessageOnlyException("Restli generator error: " + e.getMessage)
        }
      }
      case e: Throwable => {
        throw e
      }
    }

    generatorResult.getTargetFiles.asScala.toSeq
  }
}
